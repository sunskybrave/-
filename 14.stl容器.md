STL有7种主要容器：vector,list,deque,map,multimap,set,multiset


**hashtable**   
1.哈希表的底层结构？  
Java中的HashSet和HsahMap用的就是哈希表  

数据结构决定了数据的检索，维护的效率。数组的检索效率高，增删元素的效率低。而链表的增删元素的效率高，检索元素的效率低。而哈希表结合了他们的优点。检索与增删效率都高。哈希表的底层结构就是一个数组，数组的长度即哈希表的长度，数组中的每个空间(也叫桶)存放的是一条链表，链表中的每个节点用来存放元素。即一个数组的每个数组元素是一条链表，链表的每个节点存放元素，可以将数组的每个元素看做桶，桶里面可以有多个元素。桶里元素直接的数据结构是链表。  


2.哈希表如何检索元素？  

哈希表首先根据要存放的元素的key得到hash值，将这个hash值经过"特殊计算的"结果，作为数组的下标(定位桶)，进而确定将要遍历的链表。就不用遍历所有的链表，所以检索效率高。  


3.哈希表如何增删元素？  

首先一个哈希表的默认初始长度为16，即数组有16个空间(并非指能放16个元素)。默认加载因子为0.75。当向哈希表中添加元素的时候先判断是否要扩容，如果当前元素的总个数大于16*0.75那么要进行扩容，新的容量为原来的2倍。  

在向哈希表中添加元素时首先通过要添加的元素的key的hash值，经过特殊算法计算的值作为下标，确定这个元素要放到数组中的那个桶里，然后遍历这个桶里的链表中的每个元素，与key进行equals判断如果equals返回false说明这个元素在哈希表中不存在则插入。如果返回true则不插入。  

4.如何计算下标值？  

通过要插入的元素的key调用hashcode方法得到哈希值，并与哈希表的长度减一进行与运算得到数组下标。  
公式:hash(key)&table.length-1  
由于哈希表表长一定是2的指数，即table.length-1的结果的二进制一定全部是1(比如16-1)与hash(key)进行与运算，即hash(key)最高位全为0，即求hash(key)与表长的余数，得到的就是下面的公式。  
hash(key)%(table.length)。  

这就可以解释当表长为16，元素个数不超过16*0.75时，插入元素就会根据要插入元素的key的的hashcode值与表长取余得到下标，这样在不超过表长的前提下，元素就会散乱的分布在这16不同的桶里。而决定链表的长度主要由加载因子决定。即使hashcode值不同但与表长进行取余，得到的下标会相同，这样就会散乱的分布在16个桶里  

5.哈希表中的单链表的稀疏程度决定因素？  

单链表的稀疏程度决定检索效率高低，而加载因子可以决定元素的个数，进而决定单链表的稀疏程度，哈希初始初始容量越大，加载因子越小，而实际存放的元素越少，单链表越稀疏越接近于数组。检索效率越高，但是越接近于数组，增钱效率就降低了，所以加载因子的大小一定要根据实际需求。  

6.hashcode怎么写？  
由哈希表在插入元素的时候会调用对象的hashcode方法和equals方法，因此重写十分必要。  
原则:  
两个对象的equals返回true,那么他们的hashcode一定要相等。  

两个对象的hashcode相同，他们的equals不一定返回true。 

**解决哈希冲突的方法**  
**1.开放定址法**    
这种方法也称再散列法，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。这种方法有一个通用的再散列函数形式：    

Hi=（H（key）+di）% m   i=1，2，…，n    

其中H（key）为哈希函数，m 为表长，di称为增量序列。增量序列的取值方式不同，相应的再散列方式也不同。主要有以下三种：  

线性探测再散列  
dii=1，2，3，…，m-1  

这种方法的特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。  

二次探测再散列  
di=12，-12，22，-22，…，k2，-k2    ( k<=m/2 )  

这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。  

伪随机探测再散列  
di=伪随机数序列。  

具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），并给定一个随机数做起点。  

例如，已知哈希表长度m=11，哈希函数为：H（key）= key  %  11，则H（47）=3，H（26）=4，H（60）=5，假设下一个关键字为69，则H（69）=3，与47冲突。  

如果用线性探测再散列处理冲突，下一个哈希地址为H1=（3 + 1）% 11 = 4，仍然冲突，再找下一个哈希地址为H2=（3 + 2）% 11 = 5，还是冲突，继续找下一个哈希地址为H3=（3 + 3）% 11 = 6，此时不再冲突，将69填入5号单元。  

如果用二次探测再散列处理冲突，下一个哈希地址为H1=（3 + 12）% 11 = 4，仍然冲突，再找下一个哈希地址为H2=（3 - 12）% 11 = 2，此时不再冲突，将69填入2号单元。  

如果用伪随机探测再散列处理冲突，且伪随机数序列为：2，5，9，……..，则下一个哈希地址为H1=（3 + 2）% 11 = 5，仍然冲突，再找下一个哈希地址为H2=（3 + 5）% 11 = 8，此时不再冲突，将69填入8号单元。  

**再哈希法**  
这种方法是同时构造多个不同的哈希函数：  

Hi=RH1（key）  i=1，2，…，k  

当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。  

**链地址法**
这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。  

**建立公共溢出区**
这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。  

优缺点
开放散列（open hashing）/ 拉链法（针对桶链结构）  
1）优点： ①对于记录总数频繁可变的情况，处理的比较好（也就是避免了动态调整的开销） ②由于记录存储在结点中，而结点是动态分配，不会造成内存的浪费，所以尤其适合那种记录本身尺寸（size）很大的情况，因为此时指针的开销可以忽略不计了 ③删除记录时，比较方便，直接通过指针操作即可  
 
2）缺点： ①存储的记录是随机分布在内存中的，这样在查询记录时，相比结构紧凑的数据类型（比如数组），哈希表的跳转访问会带来额外的时间开销 ②如果所有的 key-value 对是可以提前预知，并之后不会发生变化时（即不允许插入和删除），可以人为创建一个不会产生冲突的完美哈希函数（perfect hash function），此时封闭散列的性能将远高于开放散列 ③由于使用指针，记录不容易进行序列化（serialize）操作  
封闭散列（closed hashing）/ 开放定址法  
1）优点： ①记录更容易进行序列化（serialize）操作 ②如果记录总数可以预知，可以创建完美哈希函数，此时处理数据的效率是非常高的  
 
2）缺点： ①存储记录的数目不能超过桶数组的长度，如果超过就需要扩容，而扩容会导致某次操作的时间成本飙升，这在实时或者交互式应用中可能会是一个严重的缺陷 ②使用探测序列，有可能其计算的时间成本过高，导致哈希表的处理性能降低 ③由于记录是存放在桶数组中的，而桶数组必然存在空槽，所以当记录本身尺寸（size）很大并且记录总数规模很大时，空槽占用的空间会导致明显的内存浪费 ④删除记录时，比较麻烦。比如需要删除记录a，记录b是在a之后插入桶数组的，但是和记录a有冲突，是通过探测序列再次跳转找到的地址，所以如果直接删除a，a的位置变为空槽，而空槽是查询记录失败的终止条件，这样会导致记录b在a的位置重新插入数据前不可见，所以不能直接删除a，而是设置删除标记。这就需要额外的空间和操作。  
