应用层  

比如ping,ping是应用程序，不是协议，使用ICMP报文来检测网络连接  
比如DNS协议，提供机器域名到IP地址的转换  

传输层  

为两台主机提供端对端的通信，传输层屏蔽了底层的细节，只需要关心通信的起始端和目的端，而不在乎数据包的中转过程  
传输层主要有三个协议：TCP、UDP、SCTP  

TCP 可靠的、面向连接的、基于流的服务，采用超时重传、数据确认等方式来确保数据被正确的发送到对端，因此是可靠的  
UDP 不可靠的、无连接和基于数据报的服务  
STCP 用于在因特网上传输电话信号而设计  

网络层 

实现数据包的选路和转发，即选择两台主机之间的中间节点，以确定两台主机之间的通信路径  
网络层最核心的是IP协议，IP协议根据数据包的目的IP地址来决定如何投递它，IP协议采用逐跳(hop by hop)的方式来确定通信路径   
网络层另外一个重要的协议是ICMP协议，因特网控制报文协议，是IP协议的重要补充，主要用于检测网络连接  

数据链路层  
ARP 地址解析协议 RARP 逆地址解析协议  实现ip地址和物理地址（多是MAC地址）之间的转换   

网络层使用IP地址查找一台机器，数据链路层通过ARP将IP地址转换成物理地址
RARP主要用于网络上的某些无盘工作站，因为缺乏存储设备，无盘工作站无法记住自己IP地址，通过网卡上的物理地址来向网络管理服务器查询自己的IP地址  

封装  ->进行传输    
应用程序数据+TCP/UDP头部+IP头部+以太网头部  
分用  ->获取数据  
各层依次解析数据  

 
IP服务的特点 
IP协议提供无状态、无连接、不可靠的服务  
无状态指IP通信双方不同步传输数据的状态信息，因此所有IP数据报的发送、传输和接受都是相互独立、没有上下文关系，可能会出现乱序和重复发送，需要上层的协议如TCP协议自己去处理乱序、重复的报文段  
无连接指IP通信双方都不长久地维持对方的任何消息，上层协议每次发送数据的时候都必须要明确指定对方的IP地址  
不可靠指IP协议不保证IP数据报准确地到达接收端，只是尽最大努力，因此TCP协议需要自己实现数据的确认和超时重传  

TCP黏包   
1、什么是粘包/拆包  
一般所谓的TCP粘包是在一次接收数据不能完全地体现一个完整的消息数据。TCP通讯为何存在粘包呢？主要原因是TCP是以流的方式来处理数据，再加上网络上MTU的往往小于在应用处理的消息数据，所以就会引发一次接收的数据无法满足消息的需要，导致粘包的存在。处理粘包的唯一方法就是制定应用层的数据通讯协议，通过协议来规范现有接收的数据是否满足消息数据的需要。    

所谓粘包问题主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的。   

udp的recvfrom是阻塞的，一个recvfrom(x)必须对唯一一个sendinto(y),收完了x个字节的数据就算完成,若是y>x数据就丢失，这意味着udp根本不会粘包，但是会丢数据，不可靠  

tcp的协议数据不会丢，没有收完包，下次接收，会继续上次继续接收，己端总是在收到ack时才会清除缓冲区内容。数据是可靠的，但是会粘包。

注意：只有TCP有粘包现象，UDP永远不会粘包，因为TCP是基于数据流的协议，而UDP是基于数据报的协议  

两种情况下会发生粘包。  
a.发送端需要等缓冲区满才发送出去，造成粘包（发送数据时间间隔很短，数据了很小，会合到一起，产生粘包  ->>>>TCP内部nagle算法,优化传输效率:数据量小且间隔时间小的数据会合并为一次进行发送  ）  
b.接收方不及时接收缓冲区的包，造成多个包接收（客户端发送了一段数据，服务端只收了一小部分，服务端下次再收的时候还是从缓冲区拿上次遗留的数据，产生粘包）  
2、解决办法  
2.1、消息定长，报文大小固定长度，不够空格补全，发送和接收方遵循相同的约定，这样即使粘包了通过接收方编程实现获取定长报文也能区分。  
2.2、包尾添加特殊分隔符，例如每条报文结束都添加回车换行符（例如FTP协议）或者指定特殊字符作为报文分隔符，接收方通过特殊分隔符切分报文区分。  
2.3、将消息分为消息头和消息体，消息头中包含表示信息的总长度（或者消息体长度）的字段  

TCP服务的特点   
面向连接、字节流、可靠传输    

HTTP 就是一个无状态的协议   
小明经常去校门口的超市买东西，老板娘时间久了就会记得他，可能以后会给他优惠，但是Http类似就是老板娘就是得了健忘症一样，每天认为来的顾客都是第一次  
Cookie 就是为了解决 HTTP 协议无状态的问题    
服务端（医生）在收到客户端（患者）请求的时候，将一些用户标识信息加入到 Cookie （病例）中，随着响应返回给客户端，客户端将 Cookie 中的信息存储在本地，下次再请求此服务器的时候，再将 Cookie 中携带的数据原样传输给服务端，此时服务端就能通过 Cookie 中的用户标识，识别出这是之前请求过的某个用户。  
