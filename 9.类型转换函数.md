c语言中的类型转换：  
1.隐式类型转换  
2.显示类型转换，即强制类型转换      

c++中的类型转换分四种  
**1.static_cast   提供的是编译时期的静态类型检测**  

1）完成基础数据类型的转换  
由于没有运行时类型检查来保证转换的安全性，不安全  
2）同一个继承体系中类型的转换  
需要注意区分向上转换和向下转换，向上转换即子类转换成父类，即父类指针指向基类，没有问题，但是向下转换即父类转换成子类会有问题，可能会出现未定义的行为  
由于没有运行时类型检查，下行转换不安全  
3）任意类型与空指针类型void*之间的转换  
4）static_cast不能转换掉原有类型的const、volatile、或者 __unaligned属性  

c++ 的任何的隐式转换都是使用 static_cast 来实现  

**2.dynamic_cast 提供的是运行时检测**  

dynamic_cast运算符的主要用途：将基类的指针或引用安全地转换成派生类的指针或引用，并用派生类的指针或引用调用非虚函数。如果是基类指针或引用调用的是虚函数无需转换就能在运行时调用派生类的虚函数。  

1.dynamic_cast是在运行时检查的，用于在集成体系中进行安全的向下转换downcast(当然也可以向上转换，但没必要，因为可以用虚函数实现)
即：基类指针/引用 转换成 派生类指针/引用  
如果源和目标没有继承/被继承关系，编译器会报错！  
2.dynamic_cast是4个转换中唯一的RTTI操作符，提供运行时类型检查。  
3.dynamic_cast不是强制转换，而是带有某种”咨询“性质的，如果不能转换，返回NULL。这是强制转换做不到的。  
4.源类中必须要有虚函数，保证多态，才能使用dynamic_cast<source>(expression)  

虚函数对于dynamic_cast转换的作用  
为何使用dynamic_cast转换类指针时，需要虚函数呢。  
Dynamic_cast转换是在运行时进行转换，运行时转换就需要知道类对象的信息（继承关系等）。  
如何在运行时获取到这个信息——虚函数表。  
C++对象模型中，对象实例最前面的就是虚函数表指针，  
通过这个指针可以获取到该类对象的所有虚函数，包括父类的。  
因为派生类会继承基类的虚函数表，所以通过这个虚函数表，我们就可以知道该类对象的父类，在转换的时候就可以用来判断对象有无继承关系。  
所以虚函数对于正确的基类指针转换为子类指针是非常重要的。  

**3.reinterpret_cast**   
重解释转换则是任何两个类型之间都可以转换，是最不安全的一种类型转换，尽量不要用      

**4.const_cast**   
去除指针或引用的const属性。  
1、转化常量指针为非常量的指针，并且仍然指向原来的对象；    
2、转化常量引用为非常量的引用，并且仍然指向原来的对象；   
3、const_cast一般用于修改指针。如const int *ptr形式。  

常见问题：
类型转换有哪些？各适用什么环境？dynamic_cast转换失败时，会出现什么情况(对指针，返回NULL.对引用，抛出bad_cast异常)？
 静态类型转换，static_cast，基本类型之间和具有继承关系的类型。
例子A,double类型转换成int。B,将子类对象转换成基类对象。
常量类型转换，const_cast, 去除指针变量的常量属性。
无法将非指针的常量转换为普通变量。
动态类型转换，dynamic_cast，运行时进行转换分析的，并非在编译时进行。dynamic_cast转换符只能用于含有虚函数的类。dynamic_cast用于类层次间的向上转换和向下转换，还可以用于类间的交叉转换。在类层次间进行向上转换，即子类转换为父类，此时完成的功能和static_cast是相同的，因为编译器默认向上转换总是安全的。向下转换时，dynamic_cast具有类型检查的功能，更加安全。类间的交叉转换指的是子类的多个父类之间指针或引用的转换。该函数只能在继承类对象的指针之间或引用之间进行类型转换，或者有虚函数的类。

