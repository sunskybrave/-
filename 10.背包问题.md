1) 0-1背包问题
有N件物品和一个容量为C的背包。（每种物品均只有一件）第i件物品的费用是w[i]，价值是v[i]。求解将哪些物品装入背包可使价值总和最大。
这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。
用子问题定义状态：即dp[i][c]表示前i件物品恰放入一个容量为c的背包可以获得的最大价值。则其状态转移方程便是：
    f[i][c]=max{f[i-1][c],f[i-1][c-w[i]]+v[i]}
    
```c++
    int n;
    int c;
    int dp[100][100];

    n=3;
    c=4;
    int v[]={3000,2000,1500};
    int w[]={4,3,1};

    for(int i=0;i<100;++i)
        for(int j=0;j<100;++j)
            dp[i][j]=0;

    for(int i=0;i<n;++i)
        for(int j=1;j<=c;++j)
        {
            if(i==0)
            {
                dp[i][j]=j>=w[i]?v[i]:0;
                cout<<"i="<<i<<"j="<<j<<'\t'<<dp[i][j]<<endl;
                continue;
            }

            if(j>=w[i])
            {
                int value1=dp[i-1][j];
                int value2=dp[i-1][j-w[i]]+v[i];
                dp[i][j]=value1>value2?value1:value2;
                cout<<"i="<<i<<"j="<<j<<'\t'<<dp[i][j]<<endl;
            }
            else
            {
                dp[i][j]=dp[i-1][j];
                cout<<"i="<<i<<"j="<<j<<'\t'<<dp[i][j]<<endl;
            }
        }

    for(int i=0;i<n;++i)
    {
        for(int j=1;j<=c;++j)
            cout<<dp[i][j]<<'\t';
        cout<<endl;
    }

    cout<<"max="<<dp[n-1][c];
```
更加厉害的一种方法是使用一维数组，但是需要逆序，为什么要逆序呢？逆序可以保证状态方程右侧的值都是第i-1件物品时的值，而不是当前i件的，其实就是保证了只买一次当前物品，体现0-1背包的只买一次  
```
for i=1..N
   for v=V..0
        f[v]=max{f[v],f[v-c[i]]+w[i]};
```
