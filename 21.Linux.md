## linux方面，linux系统怎么启动，分几个步骤，linux下查看进程怎么操作   
https://www.runoob.com/linux/linux-system-boot.html   
1.内核的引导。
当计算机打开电源后，首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动。    
操作系统接管硬件以后，首先读入 /boot 目录下的内核文件。     
2.运行 init。   
init 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。   
init 程序首先是需要读取配置文件 /etc/inittab。     
3.系统初始化。      
它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。     
4.建立终端 。     
init接下来会打开6个终端，以便用户登录系统。在inittab中的以下6行就是定义了6个终端：    
5.用户登录系统。   

## linux 用户空间 内核空间  
Linux 操作系统和驱动程序运行在内核空间，应用程序运行在用户空间  

os分配给每个进程一个独立的、连续的、虚拟的地址内存空间，该大小一般是4G（32位操作系统，即2的32次方），其中将高地址值的内存空间分配给os占用，linux os占用1G，window os占用2G；其余内存地址空间分配给进程使用。   

进程寻址空间0~4G
进程在用户态只能访问0~3G，只有进入内核态才能访问3G~4G    
进程通过系统调用进入内核态   
每个进程虚拟空间的3G~4G部分是相同的    


1、用户空间（进程）是否有高端内存概念？   

用户进程没有高端内存概念。只有在内核空间才存在高端内存。用户进程最多只可以访问3G物理内存，而内核进程可以访问所有物理内存。   

2、64位内核中有高端内存吗？   

目前现实中，64位Linux内核不存在高端内存，因为64位内核可以支持超过512GB内存。若机器安装的物理内存超过内核地址空间范围，就会存在高端内存。  

3、用户进程能访问多少物理内存？内核代码能访问多少物理内存？  

32位系统用户进程最大可以访问3GB，内核代码可以访问所有物理内存。  

64位系统用户进程最大可以访问超过512GB，内核代码可以访问所有物理内存。   

4、高端内存和物理地址、逻辑地址、线性地址的关系？   

高端内存只和逻辑地址有关系，和逻辑地址、物理地址没有直接关系。   

## 虚拟内存怎样转到物理内存
https://blog.csdn.net/lvyibin890/article/details/82217193     
操作系统有虚拟内存与物理内存的概念。在很久以前，还没有虚拟内存概念的时候，程序寻址用的都是物理地址。程序能寻址的范围是有限的，这取决于CPU的地址线条数。比如在32位平台下，寻址的范围是2^32也就是4G。并且这是固定的，如果没有虚拟内存，且每次开启一个进程都给4G的物理内存，就可能会出现很多问题：  

1.因为我的物理内存时有限的，当有多个进程要执行的时候，都要给4G内存，很显然你内存小一点，这很快就分配完了，于是没有得到分配资源的进程就只能等待。当一个进程执行完了以后，再将等待的进程装入内存。这种频繁的装入内存的操作是很没效率的      
2.由于指令都是直接访问物理内存的，那么我这个进程就可以修改其他进程的数据，甚至会修改内核地址空间的数据，这是我们不想看到的     
3.因为内存时随机分配的，所以程序运行的地址也是不正确的。       

一个进程运行时都会得到4G的虚拟内存。这个虚拟内存你可以认为，每个进程都认为自己拥有4G的空间，这只是每个进程认为的，但是实际上，在虚拟内存对应的物理内存上，可能只对应的一点点的物理内存，实际用了多少内存，就会对应多少物理内存。     
进程得到的这4G虚拟内存是一个连续的地址空间（这也只是进程认为），而实际上，它通常是被分隔成多个物理内存碎片，还有一部分存储在外部磁盘存储器上，在需要时进行数据交换。  

进程开始要访问一个地址，它可能会经历下面的过程

1.每次我要访问地址空间上的某一个地址，都需要把地址翻译为实际物理内存地址   
2.所有进程共享这整一块物理内存，每个进程只把自己目前需要的虚拟地址空间映射到物理内存上   
3.进程需要知道哪些地址空间上的数据在物理内存上，哪些不在（可能这部分存储在磁盘上），还有在物理内存上的哪里，这就需要通过页表来记录   
4.页表的每一个表项分两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址（如果在的话）   
5.当进程访问某个虚拟地址的时候，就会先去看页表，如果发现对应的数据不在物理内存上，就会发生缺页异常    
6.缺页异常的处理过程，操作系统立即阻塞该进程，并将硬盘里对应的页换入内存，然后使该进程就绪，如果内存已经满了，没有空地方了，那就找一个页覆盖，至于具体覆盖的哪个页，就需要看操作系统的页面置换算法是怎么设计的了。   

再来总结一下虚拟内存是怎么工作的    
当每个进程创建的时候，内核会为进程分配4G的虚拟内存，当进程还没有开始运行时，这只是一个内存布局。实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射）。这个时候数据和代码还是在磁盘上的。当运行到对应的程序时，进程去寻找页表，发现页表中地址没有存放在物理内存上，而是在磁盘上，于是发生缺页异常，于是将磁盘上的数据拷贝到物理内存中。    
另外在进程运行过程中，要通过malloc来动态分配内存时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。   
可以认为虚拟空间都被映射到了磁盘空间中（事实上也是按需要映射到磁盘空间上，通过mmap，mmap是用来建立虚拟空间和磁盘空间的映射关系的）    

## linux的进程调度策略，

## tcp拥塞控制的原理，以及采取的各种方法，tcp的流量控制是如何实现的，什么是滑动窗口，

## linux是如何寻址的，java垃圾收集是如何实现的，c++对象内存如何布局的。

## linux内核的东西，内核对象，操作系统是如何启动的，信号的工作机制。说一下具体工程，说一说线程池的实现机制(一直深入问，问到你无话可说).

## Linux用过哪些命令，安装一个软件需要哪些命令；

## c++内存机制

## 用宏实现判断大小的函数

## 数据库的特性

## Linux线程模型有哪些

SQL安全注入
数据库索引，什么是索引，如何证明索引是有效的
操作系统：从键盘输入到屏幕输出的整个过程
文件读写的过程，如果文件编码方式不同，读取方式怎么变
socket通信过程
c#，java里面的内存回收机制
怎么读取不同编码方式的文件内容（比如ascii、utf8）
代理模式  
truncat、drop、delete区别
http是基于tcp还是udp
tcp多长
tcp固定值吗？数据多长
arp协议是那一层的协议

Web页面请求过程；
判断链表是否环

malloc/free的底层实现
输入网址后，网络中怎样通信的流程（到黑板上画出来）
深复制和浅复制是怎么处理的；


